"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONRPCTransform = void 0;
const stream_1 = require("stream");
const JSON_RPC_RES_REGEX = /^Content-Length: ([0-9]*)\r\n\r\n/i;
class JSONRPCTransform extends stream_1.Transform {
    constructor(options) {
        options = options || {};
        options.objectMode = true;
        super(options);
        this.on('pipe', (src) => {
            if (!this.readableEncoding) {
                if (src instanceof stream_1.Readable) {
                    this.setEncoding(src.readableEncoding);
                }
            }
        });
        this._curChunk = '';
        this._state = 'content-length';
    }
    _transform(chunk, encoding, done) {
        encoding = encoding || 'utf8';
        if (Buffer.isBuffer(chunk)) {
            chunk = chunk.toString(encoding);
        }
        this._curChunk += chunk;
        if (this._state === 'content-length') {
            const match = this._curChunk.toString().match(JSON_RPC_RES_REGEX);
            if (!match || !Array.isArray(match) || match.length < 2) {
                done(new Error(`[_transform] Bad header: ${this._curChunk || chunk}`));
                return;
            }
            this._curContentLength = Number(match[1]);
            this._curChunk = this._curChunk.substring(match[0].length);
            this._state = 'jsonrpc';
        }
        if (this._state === 'jsonrpc') {
            if (this._curChunk.length >= this._curContentLength) {
                this.push(this._reencode(this._curChunk.length > this._curContentLength ? this._curChunk.substring(0, this._curContentLength) : this._curChunk, encoding));
                this._curChunk = this._curChunk.length > this._curContentLength ? this._curChunk.substring(this._curContentLength) : '';
                this._state = 'content-length';
                const match = this._curChunk.match(JSON_RPC_RES_REGEX);
                if (match && Array.isArray(match) && match.length >= 2 && (this._curChunk.length - match[0].length) >= Number(match[1])) {
                    const c = this._curChunk;
                    this._curChunk = '';
                    this._transform(c, encoding, () => { });
                }
            }
        }
        done();
    }
    _reencode(chunk, chunkEncoding) {
        if (this.readableEncoding && this.readableEncoding != chunkEncoding) {
            return Buffer.from(chunk, chunkEncoding).toString(this.readableEncoding);
        }
        else if (this.readableEncoding) {
            return chunk;
        }
        else {
            return Buffer.from(chunk, chunkEncoding);
        }
    }
    ;
    static createStream(readStream, options) {
        const jrt = new JSONRPCTransform(options);
        if (readStream) {
            readStream.pipe(jrt);
        }
        return jrt;
    }
}
exports.JSONRPCTransform = JSONRPCTransform;
//# sourceMappingURL=jsonRpcTransform.js.map